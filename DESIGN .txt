Action:
executeAnimationAction - moved from Functions, Action was in the name as well as multiple references to
Action specific data (cohesion)
executeAction - moved from Functions, Action was in the name and data specific to the action class was
referenced in the body (cohesion)
executeActivityAction - moved from Functions, Action was in the name and there were many references to
data specific to the action class (cohesion)

Background:

Entity:
nextImage - moved from Functions, only referenced entity class data (cohesion) and this allowed the function
to take no parameters
executeSaplingActivity - moved from Functions, multiple references to entity class data (cohesion), also it just makes
sense that the entities would execute their own activities.
executeTreeActivity- moved from Functions, multiple references to entity class data (cohesion), also it just makes
sense that the entities would execute their own activities.
executeDudeNotFullActivity - moved from Functions, multiple references to entity class data (cohesion), also it just makes
sense that the entities would execute their own activities.
executeDudeFullActivity - moved from Functions, multiple references to entity class data (cohesion), also it just makes
sense that the entities would execute their own activities.
moveToFull - moved from Functions, multiple references to entity class data (cohesion)
transformFull - moved from Functions, only references entity class data (cohesion), and it makes sense
that entities would deal with transforming themselves
getAnimationPeriod - moved from Functions, deals exclusively with entity class data (cohesion)
transformNotFull - moved from Functions, deals exclusively with entity class data (cohesion), and it makes sense
that entities would deal with transforming themselves
transformPlant - moved from Functions, multiple references to entity class data (cohesion), and it makes sense
that entities would deal with transforming themselves
transformTree - moved from Functions, multiple references to entity class data (cohesion), and it makes sense
that entities would deal with transforming themselves
transformSapling - moved from Functions, multiple references to entity class data (cohesion), and it makes sense
that entities would deal with transforming themselves
scheduleActions - moved from Functions, this one was conflicting because the name makes it sound like it should go
in the eventscheduler, but it only called event scheduler method, whereas it referenced entity specific data
moveEntity - moved from Functions, exclusively makes references to entity specific data and it makes sense
that entities could move themselves
nextPositionFadouiry - moved from Functions, this one was tricky, it makese reference to entity specific data but
part of that data is a point so it makes reference to point specific data (x, y). Ultimately i decided that the point
really didn't need access to entity data, in terms of heirarchy i would put it lower than entity.
moveToFairy - moved from Functions, exclusively makes references to entity specific data and it makes sense
that entities could move themselves
removeEntity - moved from Functions, makes one reference to entity specific data, i guess it makes sense that
entities could remove themselves
addEntity - moved from Functions, deals with data specfic to both WorldModel and Entity, but for world it references
data to use a method to change it, and there are more calls to Entity data, but grammatically I don't like it
executeFairyActivity - moved from Functions, multiple references to entity class data (cohesion), also it just makes
sense that the entities would execute their own activities.
tryAddEntity - moved from Functions, deals exclusively with entity class data (cohesion)
nextPositionDude - moved from functions, references both entity and point class data, in terms of heirarchy
point doesn't need access to entity data
moveToNotFull - moved from functions, references two entity objects data, (cohesion)

Event:
removePendingEvent - I saw that I had to put something in the Event class and this was the only function that
referenced Event data specifically, even though it also accesses EventScheduler data,

EventScheduler:
scheduleEvent - moved from Functions, well its in the name, and it exclusively deals with EventScheduler data
(cohesion)
unscheduleAllEvents - moved from Functions, deals with data specific to EventScheduler and the name makes sense
updateOnTime - movd from Functions, deals exclusively with EventScheduler specific data and it takes only one
double parameter rather than a class

ImageStore:
getImageList - moved from Functions, its in the name and deals exclusively with ImageStore data
loadImages - moved from Functions, its in the name and only makes one reference to ImageStore data

Point:
distanceSquared - moved from Functions, I thought a lot about this one, because it deals with two instances
of the Point class, I almost felt like it shouldn't be in the Point class at all. But it only deals with point
class data so I guess you could call it on a point with another one.
adjacent - moved from Functions, same reasoning as distance squared ^

Viewport:
contains - moved from Functions, this function deals with data from both Point and Viewport, so for me it came down
to what makese sense with the title. point contains viewport? or viewport contains point? the latter makes more
grammatical sense to me.
shift - moved from Functions, deals exclusively with Viewport specific data, now it only takes two ints
worldToViewport - moved from Functions, its in the name and it only deals with ViewPort specif data  (cohesion)
viewportToWorld - moved from Functions, its in the name and it only deals with ViewPort specif data  (cohesion)

VirtualWorld:
draw - moved from Functions, deals mostly with it's own class data, except when referencing class data that's another
class with it's own data
update - moved from Functions, deals with it's own data and only takes one double parameter
mousePressed - not too sure about this one, it accesses entity data but that wasn't a paremter, it was initialiazed in
the body, so if it was in entity it wouldn't use 'this'. The name was the biggest clue for me.
mouseToPoint - moved from Functions, only deals with VirtualWorld data (cohesion)
keyPressed - moved from Functions, only deals with VirtualWorld data (cohesion)
Background - moved from Functions, deals with VirtualWorld data, although it sounds like it would go in Background,
it initialiazes a background wich is Background method, which takes lower precedence than data
createImageColored - moved from Functions, wasn't too sure on this one, but ultimately the only paramter that was
an object was VirtualWorld, the rest are Integers. Also it does use VirtualWorld data (cohesion)
loadImages - moved from Functions, uses VirtualWorld data (cohesion)
loadWorld - moved from Functions, uses VirtualWorld data (cohesion)
parseCommandLine - moved from Functions, uses VirtualWorld data (cohesion)
main ??
headlessMain??



WorldModel:
scheduleActions - initially i put this in VirtualWorld since it's only used there, but it makes a referecen to
WorldModel specific data that I don't think VirtualWorld needs access to
getOccupancyCell - references both point and worldmodel data but it makese sense that point shouldn't have access
to WorldModel data
setOccupancyCell - references both point and worldmodel data but it makese sense that point shouldn't have access
to WorldModel data
parseBackgroundRow - only makese references to WorldModel data
setBackgroundCell - references both point and worldmodel data but it makese sense that point shouldn't have access
to WorldModel data
getBackgroundCell - references both point and worldmodel data but it makese sense that point shouldn't have access
to WorldModel data
parseSaveFile - only makes references to WorldModel data (cohesion)
load - only makes references to WorldModel data (cohesion)
getOccupant - this method takes both Point and WorldModel as paremeters, and doesn't really access the data of either,
just WorldModels data. Could really go in either one but I liked how WorldModel.getOccupant(point) works in terms of
readability
withinBounds - references both point and worldmodel data but it makese sense that point shouldn't have access
to WorldModel data
scheduleActions - only references WorldModel data once
findNearest - wasn't really sure on this one, calls both entity and worldmodel specific data but putting it in
Worldview removes need for one paramter whereas putting it in entity woulnd't because it creates the entity in
the body of the method
parseSapling - It wasn't very obvious where to put the parse functions, I just decided that
because WorldModel came first in the parameter list, and because WorldModel seemed like the paremter
that was the most encompassing class, like yeah the WorldModel should parse its entities right?
parseDude - because WorldModel came first in the parameter list, and because WorldModel seemed like the paremter
that was the most encompassing class, like yeah the WorldModel should parse its entities right?
parseFairy - because WorldModel came first in the parameter list, and because WorldModel seemed like the paremter
that was the most encompassing class, like yeah the WorldModel should parse its entities right?
parseTree - because WorldModel came first in the parameter list, and because WorldModel seemed like the paremter
that was the most encompassing class, like yeah the WorldModel should parse its entities right?
parseObstacle - because WorldModel came first in the parameter list, and because WorldModel seemed like the paremter
that was the most encompassing class, like yeah the WorldModel should parse its entities right?
parseHouse - because WorldModel came first in the parameter list, and because WorldModel seemed like the paremter
that was the most encompassing class, like yeah the WorldModel should parse its entities right?
parseStump - because WorldModel came first in the parameter list, and because WorldModel seemed like the paremter
that was the most encompassing class, like yeah the WorldModel should parse its entities right?
parseEntity - because WorldModel came first in the parameter list, and because WorldModel seemed like the paremter
that was the most encompassing class, like yeah the WorldModel should parse its entities right?
removeEntityAt - I was conflicted on this method because it calls class specific data from both world and entity
but ultimately I realized that the worldModel class relies on entity, not the other way around, so entity doesn't
need access to worldModel data as much as worldModel

WorldView:
shiftView - contains multiple references to WorldView specific data (cohesion)

